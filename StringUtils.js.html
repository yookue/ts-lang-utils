<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>StringUtils.js - TsLangUtils</title>
    
    <meta name="description" content="Common Lang Utilities for TypeScript" />
    
        <meta name="keywords" content="yookue, commons-lang, array-utils, boolean-utils, date-utils, json-utils, number-utils, object-utils, random-utils, regex-utils, string-utils, thread-utils, tree-utils" />
        <meta name="keyword" content="yookue, commons-lang, array-utils, boolean-utils, date-utils, json-utils, number-utils, object-utils, random-utils, regex-utils, string-utils, thread-utils, tree-utils" />
    
    
    
    <meta property="og:title" content="TsLangUtils"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    <meta property="og:site_name" content="ts-lang-utils"/>
    <meta property="og:url" content="https://yookue.github.io/ts-lang-utils"/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/yookue/ts-lang-utils" target="_blank" class="menu-item" id="repo_link" >Github</a></h2><h3>Classes</h3><ul><li><a href="ArrayUtils.html">ArrayUtils</a><ul class='methods'><li data-type='method'><a href="ArrayUtils.html#.allEmpty">allEmpty</a></li><li data-type='method'><a href="ArrayUtils.html#.allNil">allNil</a></li><li data-type='method'><a href="ArrayUtils.html#.allNotEmpty">allNotEmpty</a></li><li data-type='method'><a href="ArrayUtils.html#.allNotNil">allNotNil</a></li><li data-type='method'><a href="ArrayUtils.html#.anyEmpty">anyEmpty</a></li><li data-type='method'><a href="ArrayUtils.html#.anyNil">anyNil</a></li><li data-type='method'><a href="ArrayUtils.html#.anyNotEmpty">anyNotEmpty</a></li><li data-type='method'><a href="ArrayUtils.html#.anyNotNil">anyNotNil</a></li><li data-type='method'><a href="ArrayUtils.html#.asArray">asArray</a></li><li data-type='method'><a href="ArrayUtils.html#.firstNotEmpty">firstNotEmpty</a></li><li data-type='method'><a href="ArrayUtils.html#.firstNotNil">firstNotNil</a></li><li data-type='method'><a href="ArrayUtils.html#.getFirst">getFirst</a></li><li data-type='method'><a href="ArrayUtils.html#.getLast">getLast</a></li><li data-type='method'><a href="ArrayUtils.html#.getLength">getLength</a></li><li data-type='method'><a href="ArrayUtils.html#.getTypeof">getTypeof</a></li><li data-type='method'><a href="ArrayUtils.html#.includes">includes</a></li><li data-type='method'><a href="ArrayUtils.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="ArrayUtils.html#.isNotEmpty">isNotEmpty</a></li><li data-type='method'><a href="ArrayUtils.html#.isTypeof">isTypeof</a></li><li data-type='method'><a href="ArrayUtils.html#.maxLength">maxLength</a></li><li data-type='method'><a href="ArrayUtils.html#.minLength">minLength</a></li><li data-type='method'><a href="ArrayUtils.html#.remove">remove</a></li><li data-type='method'><a href="ArrayUtils.html#.reverse">reverse</a></li></ul></li><li><a href="BooleanUtils.html">BooleanUtils</a><ul class='methods'><li data-type='method'><a href="BooleanUtils.html#.isFalse">isFalse</a></li><li data-type='method'><a href="BooleanUtils.html#.isNotFalse">isNotFalse</a></li><li data-type='method'><a href="BooleanUtils.html#.isNotTrue">isNotTrue</a></li><li data-type='method'><a href="BooleanUtils.html#.isTrue">isTrue</a></li><li data-type='method'><a href="BooleanUtils.html#.toString">toString</a></li><li data-type='method'><a href="BooleanUtils.html#.toString10">toString10</a></li><li data-type='method'><a href="BooleanUtils.html#.toStringOnOff">toStringOnOff</a></li><li data-type='method'><a href="BooleanUtils.html#.toStringTF">toStringTF</a></li><li data-type='method'><a href="BooleanUtils.html#.toStringTrueFalse">toStringTrueFalse</a></li><li data-type='method'><a href="BooleanUtils.html#.toStringYN">toStringYN</a></li><li data-type='method'><a href="BooleanUtils.html#.toStringYesNo">toStringYesNo</a></li></ul></li><li><a href="DateUtils.html">DateUtils</a><ul class='methods'><li data-type='method'><a href="DateUtils.html#.addDay">addDay</a></li><li data-type='method'><a href="DateUtils.html#.addMonth">addMonth</a></li><li data-type='method'><a href="DateUtils.html#.addYear">addYear</a></li><li data-type='method'><a href="DateUtils.html#.formatDateTime">formatDateTime</a></li><li data-type='method'><a href="DateUtils.html#.getCurrentDate">getCurrentDate</a></li><li data-type='method'><a href="DateUtils.html#.getCurrentDateTime">getCurrentDateTime</a></li><li data-type='method'><a href="DateUtils.html#.getCurrentTime">getCurrentTime</a></li><li data-type='method'><a href="DateUtils.html#.getEndOfDay">getEndOfDay</a></li><li data-type='method'><a href="DateUtils.html#.getEndOfMonth">getEndOfMonth</a></li><li data-type='method'><a href="DateUtils.html#.getEndOfYear">getEndOfYear</a></li><li data-type='method'><a href="DateUtils.html#.getStartOfDay">getStartOfDay</a></li><li data-type='method'><a href="DateUtils.html#.getStartOfMonth">getStartOfMonth</a></li><li data-type='method'><a href="DateUtils.html#.getStartOfYear">getStartOfYear</a></li><li data-type='method'><a href="DateUtils.html#.getTimezone">getTimezone</a></li><li data-type='method'><a href="DateUtils.html#.isFirstDayOfMonth">isFirstDayOfMonth</a></li><li data-type='method'><a href="DateUtils.html#.isLastDayOfMonth">isLastDayOfMonth</a></li><li data-type='method'><a href="DateUtils.html#.isLeapYear">isLeapYear</a></li><li data-type='method'><a href="DateUtils.html#.isSameDay">isSameDay</a></li><li data-type='method'><a href="DateUtils.html#.isSameMonth">isSameMonth</a></li><li data-type='method'><a href="DateUtils.html#.isSameYear">isSameYear</a></li><li data-type='method'><a href="DateUtils.html#.isTomorrow">isTomorrow</a></li><li data-type='method'><a href="DateUtils.html#.isWeekend">isWeekend</a></li><li data-type='method'><a href="DateUtils.html#.isYesterday">isYesterday</a></li></ul></li><li><a href="JsonUtils.html">JsonUtils</a><ul class='methods'><li data-type='method'><a href="JsonUtils.html#.isJsonString">isJsonString</a></li><li data-type='method'><a href="JsonUtils.html#.toJsonString">toJsonString</a></li></ul></li><li><a href="NumberUtils.html">NumberUtils</a><ul class='methods'><li data-type='method'><a href="NumberUtils.html#.average">average</a></li><li data-type='method'><a href="NumberUtils.html#.isInteger">isInteger</a></li><li data-type='method'><a href="NumberUtils.html#.max">max</a></li><li data-type='method'><a href="NumberUtils.html#.min">min</a></li><li data-type='method'><a href="NumberUtils.html#.sum">sum</a></li><li data-type='method'><a href="NumberUtils.html#.toFloat">toFloat</a></li><li data-type='method'><a href="NumberUtils.html#.toInteger">toInteger</a></li></ul></li><li><a href="ObjectUtils.html">ObjectUtils</a><ul class='methods'><li data-type='method'><a href="ObjectUtils.html#.getProperty">getProperty</a></li><li data-type='method'><a href="ObjectUtils.html#.hasProperty">hasProperty</a></li><li data-type='method'><a href="ObjectUtils.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="ObjectUtils.html#.isNil">isNil</a></li><li data-type='method'><a href="ObjectUtils.html#.isNotEmpty">isNotEmpty</a></li><li data-type='method'><a href="ObjectUtils.html#.isNotNil">isNotNil</a></li><li data-type='method'><a href="ObjectUtils.html#.isNotNull">isNotNull</a></li><li data-type='method'><a href="ObjectUtils.html#.isNotUndefined">isNotUndefined</a></li><li data-type='method'><a href="ObjectUtils.html#.isNull">isNull</a></li><li data-type='method'><a href="ObjectUtils.html#.isPlainObject">isPlainObject</a></li><li data-type='method'><a href="ObjectUtils.html#.isPromiseObject">isPromiseObject</a></li><li data-type='method'><a href="ObjectUtils.html#.isPrototype">isPrototype</a></li><li data-type='method'><a href="ObjectUtils.html#.isUndefined">isUndefined</a></li><li data-type='method'><a href="ObjectUtils.html#.keys">keys</a></li><li data-type='method'><a href="ObjectUtils.html#.setProperty">setProperty</a></li><li data-type='method'><a href="ObjectUtils.html#.toString">toString</a></li><li data-type='method'><a href="ObjectUtils.html#.toStringTag">toStringTag</a></li></ul></li><li><a href="RandomUtils.html">RandomUtils</a><ul class='methods'><li data-type='method'><a href="RandomUtils.html#.randomBoolean">randomBoolean</a></li><li data-type='method'><a href="RandomUtils.html#.randomElement">randomElement</a></li><li data-type='method'><a href="RandomUtils.html#.randomElements">randomElements</a></li><li data-type='method'><a href="RandomUtils.html#.randomInteger">randomInteger</a></li><li data-type='method'><a href="RandomUtils.html#.randomIntegers">randomIntegers</a></li><li data-type='method'><a href="RandomUtils.html#.randomNumber">randomNumber</a></li><li data-type='method'><a href="RandomUtils.html#.randomNumbers">randomNumbers</a></li></ul></li><li><a href="RegexUtils.html">RegexUtils</a><ul class='methods'><li data-type='method'><a href="RegexUtils.html#.extractWords">extractWords</a></li></ul></li><li><a href="StringUtils.html">StringUtils</a><ul class='methods'><li data-type='method'><a href="StringUtils.html#.allBlank">allBlank</a></li><li data-type='method'><a href="StringUtils.html#.allEmpty">allEmpty</a></li><li data-type='method'><a href="StringUtils.html#.allNotBlank">allNotBlank</a></li><li data-type='method'><a href="StringUtils.html#.allNotEmpty">allNotEmpty</a></li><li data-type='method'><a href="StringUtils.html#.anyBlank">anyBlank</a></li><li data-type='method'><a href="StringUtils.html#.anyEmpty">anyEmpty</a></li><li data-type='method'><a href="StringUtils.html#.anyNotBlank">anyNotBlank</a></li><li data-type='method'><a href="StringUtils.html#.anyNotEmpty">anyNotEmpty</a></li><li data-type='method'><a href="StringUtils.html#.appendIfMissing">appendIfMissing</a></li><li data-type='method'><a href="StringUtils.html#.appendIfMissingIgnoreCase">appendIfMissingIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.capitalizeFirst">capitalizeFirst</a></li><li data-type='method'><a href="StringUtils.html#.defaultIfBlank">defaultIfBlank</a></li><li data-type='method'><a href="StringUtils.html#.defaultIfEmpty">defaultIfEmpty</a></li><li data-type='method'><a href="StringUtils.html#.defaultString">defaultString</a></li><li data-type='method'><a href="StringUtils.html#.endsWith">endsWith</a></li><li data-type='method'><a href="StringUtils.html#.endsWithAny">endsWithAny</a></li><li data-type='method'><a href="StringUtils.html#.endsWithAnyIgnoreCase">endsWithAnyIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.endsWithIgnoreCase">endsWithIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.equals">equals</a></li><li data-type='method'><a href="StringUtils.html#.equalsAny">equalsAny</a></li><li data-type='method'><a href="StringUtils.html#.equalsAnyIgnoreCase">equalsAnyIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.equalsIgnoreCase">equalsIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.formatBrace">formatBrace</a></li><li data-type='method'><a href="StringUtils.html#.formatPercent">formatPercent</a></li><li data-type='method'><a href="StringUtils.html#.formatPlaceholder">formatPlaceholder</a></li><li data-type='method'><a href="StringUtils.html#.getLength">getLength</a></li><li data-type='method'><a href="StringUtils.html#.includes">includes</a></li><li data-type='method'><a href="StringUtils.html#.includesAny">includesAny</a></li><li data-type='method'><a href="StringUtils.html#.includesAnyIgnoreCase">includesAnyIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.includesIgnoreCase">includesIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.isBlank">isBlank</a></li><li data-type='method'><a href="StringUtils.html#.isEmpty">isEmpty</a></li><li data-type='method'><a href="StringUtils.html#.isNotBlank">isNotBlank</a></li><li data-type='method'><a href="StringUtils.html#.isNotEmpty">isNotEmpty</a></li><li data-type='method'><a href="StringUtils.html#.joinWith">joinWith</a></li><li data-type='method'><a href="StringUtils.html#.prependIfMissing">prependIfMissing</a></li><li data-type='method'><a href="StringUtils.html#.prependIfMissingIgnoreCase">prependIfMissingIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.removeEquals">removeEquals</a></li><li data-type='method'><a href="StringUtils.html#.removeEqualsIgnoreCase">removeEqualsIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.removeIncludes">removeIncludes</a></li><li data-type='method'><a href="StringUtils.html#.removeIncludesIgnoreCase">removeIncludesIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.startsWith">startsWith</a></li><li data-type='method'><a href="StringUtils.html#.startsWithAny">startsWithAny</a></li><li data-type='method'><a href="StringUtils.html#.startsWithAnyIgnoreCase">startsWithAnyIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.startsWithIgnoreCase">startsWithIgnoreCase</a></li><li data-type='method'><a href="StringUtils.html#.substringAfter">substringAfter</a></li><li data-type='method'><a href="StringUtils.html#.substringAfterLast">substringAfterLast</a></li><li data-type='method'><a href="StringUtils.html#.substringBefore">substringBefore</a></li><li data-type='method'><a href="StringUtils.html#.substringBeforeLast">substringBeforeLast</a></li><li data-type='method'><a href="StringUtils.html#.toCamelCase">toCamelCase</a></li><li data-type='method'><a href="StringUtils.html#.toKebabCase">toKebabCase</a></li><li data-type='method'><a href="StringUtils.html#.trim">trim</a></li></ul></li><li><a href="ThreadUtils.html">ThreadUtils</a><ul class='methods'><li data-type='method'><a href="ThreadUtils.html#.sleep">sleep</a></li></ul></li><li><a href="TreeUtils.html">TreeUtils</a><ul class='methods'><li data-type='method'><a href="TreeUtils.html#.forEach">forEach</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">StringUtils.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright (c) 2023 Yookue Ltd. All rights reserved.
 *
 * Licensed under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 */
import { ArrayUtils } from './ArrayUtils';
import { ObjectUtils } from './ObjectUtils';
import { RegexUtils } from './RegexUtils';
/**
 * Utilities for string
 *
 * @abstract
 * @hideconstructor
 */
export class StringUtils {
    /**
     * Returns the length of the given string
     *
     * @param {string} text the source string to check
     *
     * @return {number} the length of the given string
     */
    static getLength(text) {
        return text ? text.length : 0;
    }
    /**
     * Returns whether the given string is empty
     *
     * @param {string} text the string to check
     *
     * @return {boolean} whether the given string is empty
     *
     * @example
     * StringUtils.isEmpty(undefined);    // true
     * StringUtils.isEmpty('foobar');    // false
     */
    static isEmpty(text) {
        return !text || text.length === 0;
    }
    /**
     * Returns whether the given string is not empty
     *
     * @param {string} text the string to check
     *
     * @return {boolean} whether the given string is not empty
     *
     * @example
     * StringUtils.isNotEmpty('foobar');    // true
     */
    static isNotEmpty(text) {
        return !this.isEmpty(text);
    }
    /**
     * Returns whether the given string is blank
     *
     * @description check if all the characters in the given string is whitespace or line separators
     *
     * @param {string} text the string to check
     *
     * @return {boolean} whether the given string is blank
     *
     * @example
     * StringUtils.isBlank(undefined);    // true
     * StringUtils.isBlank('foobar');    // false
     */
    static isBlank(text) {
        return !text || (text === null || text === void 0 ? void 0 : text.length) === 0 || /^\s*$/.test(text);
    }
    /**
     * Returns whether the given string is not blank
     *
     * @param {string} text the string to check
     *
     * @return {boolean} whether the given string is not blank
     *
     * @example
     * StringUtils.isNotBlank('foobar');    // true
     */
    static isNotBlank(text) {
        return !this.isBlank(text);
    }
    /**
     * Returns whether all the given texts are empty
     *
     * @param {Array&lt;string>} texts the texts to check
     *
     * @return {boolean} whether all the given texts are empty
     *
     * @example
     * StringUtils.allEmpty(null, undefined);    // true
     * StringUtils.allEmpty(null, 'true');    // false
     */
    static allEmpty(...texts) {
        return !texts || texts.length === 0 || !texts.some(text => this.isNotEmpty(text));
    }
    /**
     * Returns whether all the given texts are not empty
     *
     * @param {Array&lt;string>} texts the texts to check
     *
     * @return {boolean} whether all the given texts are not empty
     *
     * @example
     * StringUtils.allNotEmpty(null, undefined);    // false
     * StringUtils.allNotEmpty(null, 'world');    // false
     * StringUtils.allNotEmpty('foo', 'bar');    // true
     */
    static allNotEmpty(...texts) {
        return texts &amp;&amp; texts.length > 0 &amp;&amp; !texts.some(text => this.isEmpty(text));
    }
    /**
     * Returns whether any of the given texts is empty
     *
     * @param {Array&lt;string>} texts the texts to check
     *
     * @return {boolean} whether any of the given texts is empty
     *
     * @example
     * StringUtils.anyEmpty(null, undefined);    // true
     * StringUtils.anyEmpty('foo', 'bar');    // false
     */
    static anyEmpty(...texts) {
        return !texts || texts.length === 0 || texts.some(text => this.isEmpty(text));
    }
    /**
     * Returns whether any of the given texts is not empty
     *
     * @param {Array&lt;string>} texts the texts to check
     *
     * @return {boolean} whether any of the given texts is not empty
     *
     * @example
     * StringUtils.anyNotEmpty(null, undefined);    // false
     * StringUtils.anyNotEmpty(null, 'world');    // true
     */
    static anyNotEmpty(...texts) {
        return texts &amp;&amp; (texts === null || texts === void 0 ? void 0 : texts.length) > 0 &amp;&amp; texts.some(text => this.isNotEmpty(text));
    }
    /**
     * Returns whether all the given texts are blank
     *
     * @param {Array&lt;string>} texts the texts to check
     *
     * @return {boolean} whether all the given texts are blank
     *
     * @example
     * StringUtils.allBlank(null, undefined);    // true
     * StringUtils.allBlank(null, 'true');    // false
     */
    static allBlank(...texts) {
        return !texts || texts.length === 0 || !texts.some(text => this.isNotBlank(text));
    }
    /**
     * Returns whether all the given texts are not blank
     *
     * @param {Array&lt;string>} texts the texts to check
     *
     * @return {boolean} whether all the given texts are not blank
     *
     * @example
     * StringUtils.allNotBlank(null, undefined);    // false
     * StringUtils.allNotBlank(null, 'world');    // false
     * StringUtils.allNotBlank('foo', 'bar');    // true
     */
    static allNotBlank(...texts) {
        return texts &amp;&amp; texts.length > 0 &amp;&amp; !texts.some(text => this.isBlank(text));
    }
    /**
     * Returns whether any of the given texts is blank
     *
     * @param {Array&lt;string>} texts the texts to check
     *
     * @return {boolean} whether any of the given texts is blank
     *
     * @example
     * StringUtils.anyBlank(null, undefined);    // true
     * StringUtils.anyBlank('foo', 'bar');    // false
     */
    static anyBlank(...texts) {
        return !texts || texts.length === 0 || texts.some(text => this.isBlank(text));
    }
    /**
     * Returns whether any of the given texts is not blank
     *
     * @param {Array&lt;string>} texts the texts to check
     *
     * @return {boolean} whether any of the given texts is not blank
     *
     * @example
     * StringUtils.anyNotBlank(null, undefined);    // false
     * StringUtils.anyNotBlank(null, 'world');    // true
     */
    static anyNotBlank(...texts) {
        return texts &amp;&amp; texts.length > 0 &amp;&amp; texts.some(text => this.isNotBlank(text));
    }
    /**
     * Returns a string that concat the given text and suffix
     *
     * @param {string} text the text to check
     * @param {string} suffix the suffix to append
     *
     * @return {string} a string that concat the given text and suffix
     *
     * @example
     * StringUtils.appendIfMissing('foo', 'bar');    // 'foobar'
     * StringUtils.appendIfMissing('foobar', 'bar');    // 'foobar'
     */
    static appendIfMissing(text, suffix) {
        return (!text || this.isEmpty(suffix) || this.endsWith(text, suffix)) ? text : (text + suffix);
    }
    /**
     * Returns a string that concat the given text and suffix, case-insensitive
     *
     * @param {string} text the text to check
     * @param {string} suffix the suffix to append
     *
     * @return {string} a string that concat the given text and suffix, case-insensitive
     *
     * @example
     * StringUtils.appendIfMissingIgnoreCase('foo', 'bar');    // 'foobar'
     * StringUtils.appendIfMissingIgnoreCase('foobar', 'BAR');    // 'foobar'
     */
    static appendIfMissingIgnoreCase(text, suffix) {
        return (!text || this.isEmpty(suffix) || this.endsWithIgnoreCase(text, suffix)) ? text : (text + suffix);
    }
    /**
     * Returns the first letter capitalized representation of the given string
     *
     * @param {string} text the source string to check
     *
     * @return {string} the first letter capitalized representation of the given string

     @example
     StringUtils.capitalizeFirst('foobar');    // 'Foobar'
     */
    static capitalizeFirst(text) {
        return !text ? text : text.substring(0, 1).toUpperCase() + text.substring(1);
    }
    /**
     * Returns an empty value if the given text is undefined
     *
     * @param {string} text the text to check
     *
     * @return {string} an empty value if the given text is undefined
     *
     * @example
     * StringUtils.defaultString(undefined);    // ''
     * StringUtils.defaultString(null);    // ''
     */
    static defaultString(text) {
        return text ? text : '';
    }
    /**
     * Returns the default value if the given text is empty, or the text self if it is not empty
     *
     * @param {string} text the text to check
     * @param {string} defaultValue the default value placeholder
     *
     * @return {string} the default value if the given text is empty, or the text self if it is not empty
     *
     * @example
     * StringUtils.defaultIfEmpty(undefined, 'foobar');    // 'foobar'
     */
    static defaultIfEmpty(text, defaultValue) {
        return this.isEmpty(text) ? defaultValue : text;
    }
    /**
     * Returns the default value if the given text is blank, or the text self if it is not blank
     *
     * @param {string} text the text to check
     * @param {string} defaultValue the default value placeholder
     *
     * @return {string} the default value if the given text is blank, or the text self if it is not blank
     *
     * @example
     * StringUtils.defaultIfBlank(undefined, 'foobar');    // 'foobar'
     */
    static defaultIfBlank(text, defaultValue) {
        return this.isBlank(text) ? defaultValue : text;
    }
    /**
     * Returns whether the given string ends with the suffix
     *
     * @param {string} text the source string to check
     * @param {string} suffix the target string to compare
     *
     * @return {boolean} whether the given string ends with the suffix
     *
     * @example
     * StringUtils.endsWith('foobar', 'bar');    // true
     * StringUtils.endsWith('hello', 'bar');    // false
     */
    static endsWith(text, suffix) {
        if (!text || !suffix) {
            return text === suffix;
        }
        if (text.length &lt; suffix.length) {
            return false;
        }
        return text.endsWith(suffix);
    }
    /**
     * Returns whether the given string ends with the suffix, case-insensitive
     *
     * @param {string} text the source string to check
     * @param {string} suffix the target string to compare
     *
     * @return {boolean} whether the given string ends with the suffix, case-insensitive
     *
     * @example
     * StringUtils.endsWithIgnoreCase('foobar', 'BAR');    // true
     * StringUtils.endsWithIgnoreCase('hello', 'BAR');    // false
     */
    static endsWithIgnoreCase(text, suffix) {
        if (!text || !suffix) {
            return text === suffix;
        }
        if (text.length &lt; suffix.length) {
            return false;
        }
        return text.toLowerCase().endsWith(suffix.toLowerCase());
    }
    /**
     * Returns whether the given string ends with any of the suffixes
     *
     * @param {string} text the source string to check
     * @param {Array&lt;string>} suffixes the target strings to compare
     *
     * @return {boolean} whether the given string ends with any of the suffixes
     *
     * @example
     * StringUtils.endsWithAny('foobar', ['foo', 'bar']);    // true
     * StringUtils.endsWithAny('hello', ['foo', 'bar']);    // false
     */
    static endsWithAny(text, suffixes) {
        if (!text || !suffixes || suffixes.length === 0) {
            return false;
        }
        return suffixes.some(suffix => this.endsWith(text, suffix));
    }
    /**
     * Returns whether the given string ends with any of the suffixes, case-insensitive
     *
     * @param {string} text the source string to check
     * @param {Array&lt;string>} suffixes the target strings to compare
     *
     * @return {boolean} whether the given string ends with any of the suffixes, case-insensitive
     *
     * @example
     * StringUtils.endsWithAnyIgnoreCase('foobar', ['FOO', 'BAR']);    // true
     * StringUtils.endsWithAnyIgnoreCase('hello', ['FOO', 'BAR']);    // false
     */
    static endsWithAnyIgnoreCase(text, suffixes) {
        if (!text || !suffixes || suffixes.length === 0) {
            return false;
        }
        return suffixes.some(suffix => this.endsWithIgnoreCase(text, suffix));
    }
    /**
     * Returns whether the given strings are equal
     *
     * @param {string} text the source string to check
     * @param {string} comparison the target string to compare
     *
     * @return {boolean} whether the given strings are equal
     *
     * @example
     * StringUtils.equals(undefined, null);    // false
     * StringUtils.equals('foo', 'foo');    // true
     * StringUtils.equals('foo', 'bar');    // false
     */
    static equals(text, comparison) {
        if (text === comparison) {
            return true;
        }
        if (!text || !comparison || (text === null || text === void 0 ? void 0 : text.length) !== (comparison === null || comparison === void 0 ? void 0 : comparison.length)) {
            return false;
        }
        return text === comparison;
    }
    /**
     * Returns whether the given strings are equal, case-insensitive
     *
     * @param {string} text the source string to check
     * @param {string} comparison the target string to compare
     *
     * @return {boolean} whether the given strings are equal, case-insensitive
     *
     * @example
     * StringUtils.equalsIgnoreCase('foo', 'FOO');    // true
     */
    static equalsIgnoreCase(text, comparison) {
        if (text === comparison) {
            return true;
        }
        if (!text || !comparison || (text === null || text === void 0 ? void 0 : text.length) !== (comparison === null || comparison === void 0 ? void 0 : comparison.length)) {
            return false;
        }
        return (text === null || text === void 0 ? void 0 : text.toUpperCase()) === (comparison === null || comparison === void 0 ? void 0 : comparison.toUpperCase());
    }
    /**
     * Returns whether the given string equals to any of the comparison strings
     *
     * @param {string} text the source string to check
     * @param {Array&lt;string>} comparisons the target strings to compare
     *
     * @return {boolean} whether the given string equals to any of the comparison strings
     *
     * @example
     * StringUtils.equalsAny('foo', ['foo', 'bar']);    // true
     */
    static equalsAny(text, comparisons) {
        return ArrayUtils.includes(comparisons, text);
    }
    /**
     * Returns whether the given text equals to any of the comparison strings, case-insensitive
     *
     * @param {string} text the source string to check
     * @param {Array&lt;string>} comparisons the target strings to compare
     *
     * @return {boolean} whether the given string equals to any of the comparison strings, case-insensitive
     *
     * @example
     * StringUtils.equalsAnyIgnoreCase('foo', ['FOO', 'bar']);    // true
     */
    static equalsAnyIgnoreCase(text, comparisons) {
        if (!text || !comparisons || comparisons.length === 0) {
            return false;
        }
        return comparisons.some(comparison => this.equalsIgnoreCase(text, comparison));
    }
    /**
     * Returns the replaced string of the source string ("{}" placeholder) with the given parameters
     *
     * @param {string} text the source string to inspect
     * @param {Array&lt;any>} params the parameters to replaced with
     *
     * @return {string} the replaced string of the source string
     *
     * @example
     * StringUtils.formatBrace('foo{}', 'bar');    //  'foobar'
     * StringUtils.formatBrace('foobar{}');    //  'foobar{}'
     * StringUtils.formatBrace('hello {}, foo{}', 'world', 'bar');    //  'hello world, foobar'
     */
    static formatBrace(text, ...params) {
        if (!text || text.length &lt;= 2 || !params || params.length === 0) {
            return text;
        }
        let result = text;
        for (const param of params) {
            result = result.replace('{}', ObjectUtils.toString(param, ''));
        }
        return result;
    }
    /**
     * Returns the replaced string of the source string ("%" placeholder) with the given parameters
     *
     * @param {string} text the source string to inspect
     * @param {Array&lt;any>} params the parameters to replaced with
     *
     * @return {string} the replaced string of the source string
     *
     * @see "https://github.com/samsonjs/format/blob/main/format.js"
     *
     * @example
     * StringUtils.formatPercent("foo%s", "bar");    // "foobar"
     * StringUtils.formatPercent("foobar %d", 2023);    // "foobar 2023"
     * StringUtils.formatPercent("hello %s, foo%s", "world", "bar");    // "hello world, foobar"
     */
    static formatPercent(text, ...params) {
        if (!text || text.length &lt;= 2 || !params || params.length === 0) {
            return text;
        }
        const matches = text.match(/%[bcdfjosxX]/g) || [];
        const count = ArrayUtils.minLength(matches, params);
        if (count === 0) {
            return text;
        }
        let result = text;
        for (let i = 0; i &lt; count; i++) {
            const param = params[i];
            const pattern = matches[i].substring(1);
            switch (pattern) {
                case 'b':
                case 'c':
                case 'd':
                case 'o':
                case 'x':
                case 'X':
                    try {
                        let value = undefined;
                        if (typeof param === 'string') {
                            value = Number.parseInt(param);
                        }
                        else if (param instanceof String) {
                            value = Number.parseInt(param.toString());
                        }
                        else if (typeof param === 'number') {
                            value = param;
                        }
                        if (value) {
                            if (pattern === 'b') {
                                result = result.replace(`%${pattern}`, value.toString(2));
                            }
                            else if (pattern === 'c') {
                                result = result.replace(`%${pattern}`, String.fromCharCode(value));
                            }
                            else if (pattern === 'd') {
                                result = result.replace(`%${pattern}`, value.toString(10));
                            }
                            else if (pattern === 'o') {
                                result = result.replace(`%${pattern}`, '0' + value.toString(8));
                            }
                            else if (pattern === 'x') {
                                result = result.replace(`%${pattern}`, '0x' + value.toString(16));
                            }
                            else if (pattern === 'X') {
                                result = result.replace(`%${pattern}`, '0x' + value.toString(16).toUpperCase());
                            }
                        }
                    }
                    catch (ignored) {
                        throw new TypeError(`Invalid parameter type of '${param}', index ${i}`);
                    }
                    break;
                case 'f':
                    try {
                        let value = undefined;
                        if (typeof param === 'string') {
                            value = Number.parseFloat(param);
                        }
                        else if (param instanceof String) {
                            value = Number.parseFloat(param.toString());
                        }
                        else if (typeof param === 'number') {
                            value = param;
                        }
                        if (value) {
                            result = result.replace(`%${pattern}`, '0x' + value.toString());
                        }
                    }
                    catch (ignored) {
                        throw new TypeError(`Invalid parameter type of '${param}', index ${i}`);
                    }
                    break;
                case 'j':
                    if (param === undefined || param === null) {
                        result = result.replace(`%${pattern}`, '');
                        break;
                    }
                    else if (ObjectUtils.isPlainObject(param)) {
                        result = result.replace(`%${pattern}`, JSON.stringify(param));
                        break;
                    }
                    throw new TypeError(`Invalid parameter type of '${param}', index ${i}`);
                case 's':
                    result = result.replace(`%${pattern}`, ObjectUtils.toString(param, ''));
                    break;
                default:
                    break;
            }
        }
        return result;
    }
    /**
     * Returns the replaced string of the source string (named placeholder) with the given parameters
     *
     * @param {string} text the source string to inspect
     * @param {Record&lt;string, any>} params the parameters to replaced with, in the form of key values
     *
     * @return {string} the replaced string of the source string
     *
     * @example
     * StringUtils.formatPlaceholder("foo{bar}", {bar: "bar"});    //  "foobar"
     * StringUtils.formatPlaceholder("foobar{none}");    //  "foobar{none}"
     * StringUtils.formatPlaceholder("foobar{none}", {});    //  "foobar{none}"
     * StringUtils.formatPlaceholder("hello {name}, foo{bar}", {name: "world", bar: "bar"});    //  "hello world, foobar"
     */
    static formatPlaceholder(text, params) {
        if (!text || text.length &lt;= 2 || !params) {
            return text;
        }
        let result = text;
        for (const param in params) {
            const regex = new RegExp(`\\{${param}\\}`, 'g');
            const value = params[param];
            result = result.replace(regex, (value ? value.toString() : ''));
        }
        return result;
    }
    /**
     * Returns whether the given text includes the comparison string
     *
     * @param {string} text the source string to check
     * @param {string} comparison the target string to compare
     *
     * @return {boolean} whether the given text includes the comparison string
     *
     * @example
     * StringUtils.includes('foobar', 'foo');    // true
     */
    static includes(text, comparison) {
        return text === comparison || (!!text &amp;&amp; !!comparison &amp;&amp; text.includes(comparison));
    }
    /**
     * Returns whether the given text includes the comparison string, case-insensitive
     *
     * @param {string} text the source string to check
     * @param {string} comparison the target string to compare
     *
     * @return {boolean} whether the given text includes the comparison string, case-insensitive
     *
     * @example
     * StringUtils.includesIgnoreCase('foobar', 'FOO');    // true
     */
    static includesIgnoreCase(text, comparison) {
        var _a;
        return text === comparison || (!!text &amp;&amp; !!comparison &amp;&amp; ((_a = text === null || text === void 0 ? void 0 : text.toUpperCase()) === null || _a === void 0 ? void 0 : _a.includes(comparison === null || comparison === void 0 ? void 0 : comparison.toUpperCase())));
    }
    /**
     * Returns whether the given text includes to any of the comparison strings
     *
     * @param {string} text the source string to check
     * @param {Array&lt;string>} comparisons the target strings to compare
     *
     * @return {boolean} whether the given text includes the comparison string
     *
     * @example
     * StringUtils.includesAny('foobar', ['foo', 'bar']);    // true
     */
    static includesAny(text, comparisons) {
        if (!text || !comparisons) {
            return false;
        }
        return comparisons === null || comparisons === void 0 ? void 0 : comparisons.some(comparison => this.includes(text, comparison));
    }
    /**
     * Returns whether the given text includes to any of the comparison strings, case-insensitive
     *
     * @param {string} text the source string to check
     * @param {Array&lt;string>} comparisons the target strings to compare
     *
     * @return {boolean} whether the text includes the comparison string, case-insensitive
     *
     * @example
     * StringUtils.includesAnyIgnoreCase('foobar', ['FOO', 'world']);    // true
     */
    static includesAnyIgnoreCase(text, comparisons) {
        if (!text || !comparisons || comparisons.length === 0) {
            return false;
        }
        return comparisons === null || comparisons === void 0 ? void 0 : comparisons.some(comparison => this.includesIgnoreCase(text, comparison));
    }
    /**
     * Returns the joined string with the given texts and delimiter
     *
     * @param {string | Array&lt;string>} texts the source string or strings to inspect
     * @param {string} separator the delimiter string to append between each of the given texts
     * @param {function} filter the filter to check each of the given texts should be included
     *
     * @return {string} the joined string with the given texts and delimiter
     *
     * @example
     * StringUtils.joinWith('foobar');    // 'foobar'
     * StringUtils.joinWith(['foo', 'bar'], undefined);    // 'foobar'
     * StringUtils.joinWith(['foo', 'bar', 'world'], undefined, (text => text !== 'world'));    // 'foobar'
     */
    static joinWith(texts, separator, filter) {
        if (!texts || (Array.isArray(texts) &amp;&amp; texts.length === 0)) {
            return undefined;
        }
        if (Array.isArray(texts)) {
            if (!filter) {
                return texts.join(this.defaultString(separator));
            }
            const array = texts.filter(filter);
            return (!array || array.length === 0) ? undefined : array.join(this.defaultString(separator));
        }
        return !filter ? texts : (filter(texts) ? texts : undefined);
    }
    /**
     * Returns a string that concat the given prefix and text
     *
     * @param {string} text the text to check
     * @param {string} prefix the prefix to prepend
     *
     * @return {string} a string that concat the given prefix and text
     *
     * @example
     * StringUtils.prependIfMissing('bar', 'foo');    // 'foobar'
     * StringUtils.prependIfMissing('foobar', 'foo');    // 'foobar'
     */
    static prependIfMissing(text, prefix) {
        return (!text || this.isEmpty(prefix) || this.startsWith(text, prefix)) ? text : (prefix + text);
    }
    /**
     * Returns a string that concat the given prefix and text, case-insensitive
     *
     * @param {string} text the text to check
     * @param {string} prefix the prefix to prepend
     *
     * @return {string} a string that concat the given prefix and text, case-insensitive
     *
     * @example
     * StringUtils.prependIfMissingIgnoreCase('bar', 'foo');    // 'foobar'
     * StringUtils.prependIfMissingIgnoreCase('foobar', 'FOO');    // 'foobar'
     */
    static prependIfMissingIgnoreCase(text, prefix) {
        return (!text || this.isEmpty(prefix) || this.startsWithIgnoreCase(text, prefix)) ? text : (prefix + text);
    }
    /**
     * Returns the array that excludes the elements which equals to any of the given exclusions
     *
     * @param {Array&lt;string>} texts the arrays to inspect
     * @param {string} excludes the elements array to exclude
     *
     * @return the array that excludes the elements which equals to any of the given exclusions
     *
     * @example
     * StringUtils.removeEquals(['foo', 'bar'], ['bar']);    // ['foo']
     */
    static removeEquals(texts, excludes) {
        return ArrayUtils.remove(texts, excludes);
    }
    /**
     * Returns the array that excludes the elements which equals to any of the given exclusions, case-insensitive
     *
     * @param {Array&lt;string>} texts the arrays to inspect
     * @param {string} excludes the elements array to exclude
     *
     * @return the array that excludes the elements which equals to any of the given exclusions, case-insensitive
     *
     * @example
     * StringUtils.removeEqualsIgnoreCase(['foo', 'bar'], ['BAR']);    // ['foo']
     */
    static removeEqualsIgnoreCase(texts, excludes) {
        return (!texts || texts.length === 0 || !excludes || excludes.length === 0) ? texts : texts.filter(text => !excludes.some(exclude => this.equalsIgnoreCase(text, exclude)));
    }
    /**
     * Returns the array that excludes the elements which includes any of the given exclusions
     *
     * @param {Array&lt;string>} texts the arrays to inspect
     * @param {string} excludes the elements array to exclude
     *
     * @return the array that excludes the elements which includes any of the given exclusions
     *
     * @example
     * StringUtils.removeIncludes(['foo', 'bar'], ['ar']);    // ['foo']
     */
    static removeIncludes(texts, excludes) {
        return (!texts || texts.length === 0 || !excludes || excludes.length === 0) ? texts : texts.filter(text => !excludes.some(exclude => this.includes(text, exclude)));
    }
    /**
     * Returns the array that excludes the elements which includes any of the given exclusions, case-insensitive
     *
     * @param {Array&lt;string>} texts the arrays to inspect
     * @param {string} excludes the elements array to exclude
     *
     * @return the array that excludes the elements which includes any of the given exclusions, case-insensitive
     *
     * @example
     * StringUtils.removeIncludesIgnoreCase(['foo', 'bar'], ['AR']);    // ['foo']
     */
    static removeIncludesIgnoreCase(texts, excludes) {
        return (!texts || texts.length === 0 || !excludes || excludes.length === 0) ? texts : texts.filter(text => !excludes.some(exclude => this.includesIgnoreCase(text, exclude)));
    }
    /**
     * Returns whether the given string starts with the prefix
     *
     * @param {string} text the source string to check
     * @param {string} prefix the target string to compare
     *
     * @return {boolean} whether the given string starts with the prefix
     *
     * @example
     * StringUtils.startsWith('foobar', 'foo');    // true
     * StringUtils.startsWith('hello', 'bar');    // false
     */
    static startsWith(text, prefix) {
        if (!text || !prefix) {
            return text === prefix;
        }
        if (text.length &lt; prefix.length) {
            return false;
        }
        return text.startsWith(prefix);
    }
    /**
     * Returns whether the given string starts with the prefix, case-insensitive
     *
     * @param {string} text the source string to check
     * @param {string} prefix the target string to compare
     *
     * @return {boolean} whether the given string starts with the prefix, case-insensitive
     *
     * @example
     * StringUtils.startsWithIgnoreCase('foobar', 'FOO');    // true
     * StringUtils.startsWithIgnoreCase('hello', 'BAR');    // false
     */
    static startsWithIgnoreCase(text, prefix) {
        if (!text || !prefix) {
            return text === prefix;
        }
        if (text.length &lt; prefix.length) {
            return false;
        }
        return text.toLowerCase().startsWith(prefix.toLowerCase());
    }
    /**
     * Returns whether the given string starts with any of the prefixes
     *
     * @param {string} text the source string to check
     * @param {Array&lt;string>} prefixes the target strings to compare
     *
     * @return {boolean} whether the given string starts with any of the prefixes
     *
     * @example
     * StringUtils.startsWithAny('foobar', ['foo', 'bar']);    // true
     * StringUtils.startsWithAny('hello', ['foo', 'bar']);    // false
     */
    static startsWithAny(text, prefixes) {
        if (!text || !prefixes || prefixes.length === 0) {
            return false;
        }
        return prefixes.some(prefix => this.startsWith(text, prefix));
    }
    /**
     * Returns whether the given string starts with any of the prefixes, case-insensitive
     *
     * @param {string} text the source string to check
     * @param {Array&lt;string>} prefixes the target strings to compare
     *
     * @return {boolean} whether the given string starts with any of the prefixes, case-insensitive
     *
     * @example
     * StringUtils.startsWithAnyIgnoreCase('foobar', ['FOO', 'BAR']);    // true
     * StringUtils.startsWithAnyIgnoreCase('hello', ['FOO', 'BAR']);    // false
     */
    static startsWithAnyIgnoreCase(text, prefixes) {
        if (!text || !prefixes || prefixes.length === 0) {
            return false;
        }
        return prefixes.some(prefix => this.startsWithIgnoreCase(text, prefix));
    }
    /**
     * Returns the substring after the first occurrence of the given separator (the separator is not returned)
     *
     * @param {string} text the string to get a substring from
     * @param {boolean} separator the String to search for
     *
     * @return {string} the substring after the first occurrence of the given separator
     *
     * @example
     * StringUtils.substringAfter("foo/bar/foo/bar", "/");    // 'bar/foo/bar'
     */
    static substringAfter(text, separator) {
        if (!text || !separator || separator.length === 0) {
            return undefined;
        }
        const index = text.indexOf(separator);
        return (index === -1) ? undefined : text.substring(index + separator.length);
    }
    /**
     * Returns the substring after the last occurrence of the given separator (the separator is not returned)
     *
     * @param {string} text the string to get a substring from
     * @param {boolean} separator the String to search for
     *
     * @return {string} the substring after the last occurrence of the given separator
     *
     * @example
     * StringUtils.substringAfterLast("foo/bar/foo/bar", "/");    // 'bar'
     */
    static substringAfterLast(text, separator) {
        if (!text || !separator || separator.length === 0) {
            return undefined;
        }
        const index = text.lastIndexOf(separator);
        return (index === -1) ? undefined : text.substring(index + separator.length);
    }
    /**
     * Returns the substring before the first occurrence of the given separator (the separator is not returned)
     *
     * @param {string} text the string to get a substring from
     * @param {boolean} separator the String to search for
     * @return {string} the substring before the first occurrence of the given separator
     *
     * @example
     * StringUtils.substringBefore("foo/bar/foo/bar", "/");    // 'foo'
     */
    static substringBefore(text, separator) {
        if (!text || !separator || separator.length === 0) {
            return undefined;
        }
        const index = text.indexOf(separator);
        return (index === -1) ? undefined : text.substring(0, index);
    }
    /**
     * Returns the substring before the last occurrence of the given separator (the separator is not returned)
     *
     * @param {string} text the string to get a substring from
     * @param {boolean} separator the String to search for
     *
     * @return {string} the substring before the last occurrence of the given separator
     *
     * @example
     * StringUtils.substringBeforeLast("foo/bar/foo/bar", "/");    // 'foo/bar/foo'
     */
    static substringBeforeLast(text, separator) {
        if (!text || !separator || separator.length === 0) {
            return undefined;
        }
        const index = text.lastIndexOf(separator);
        return (index === -1) ? undefined : text.substring(0, index);
    }
    /**
     * Returns the camel case representation of the given string
     *
     * @param {string} text the source string to inspect
     * @param {RegExp | string} pattern the regular expression to match
     *
     * @return {string} the camel case representation of the given string
     *
     * @example
     * StringUtils.toCamelCase('FOO BAR');    // 'fooBar'
     * StringUtils.toCamelCase('--FOO-BAR--');    // 'fooBar'
     */
    static toCamelCase(text, pattern) {
        if (!text || text.length === 0) {
            return text;
        }
        const words = RegexUtils.extractWords(text, pattern);
        return !words ? undefined : words.reduce((previous, current, index) => {
            current = current.toLowerCase();
            return previous + (index > 0 ? this.capitalizeFirst(current) : current);
        }, '');
    }
    /**
     * Returns the kebab case representation of the given string
     *
     * @param {string} text the source string to inspect
     * @param {RegExp | string} pattern the regular expression to match
     *
     * @return {string} the kebab case representation of the given string
     *
     * @example
     * StringUtils.toKebabCase('FOO BAR');    // 'foo-bar'
     * StringUtils.toKebabCase('--FOO-BAR--');    // 'foo-bar'
     */
    static toKebabCase(text, pattern) {
        if (!text || text.length === 0) {
            return text;
        }
        const words = RegexUtils.extractWords(text, pattern);
        return !words ? undefined : words.reduce((previous, current, index) => {
            return previous + (index > 0 ? '-' : '') + current.toLowerCase();
        }, '');
    }
    /**
     * Returns a string that trimmed from the given string
     *
     * @param {string} text the string to trim
     * @param {boolean} emptyAsNull whether to return null if the trimmed result is empty
     *
     * @return {string} the trimmed string value from the given string
     *
     * @example
     * StringUtils.trim("foobar", true);    // 'foobar'
     */
    static trim(text, emptyAsNull) {
        if (!text) {
            return text;
        }
        const result = text.trim();
        return (emptyAsNull &amp;&amp; this.isEmpty(result)) ? null : result;
    }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Wed Apr 03 2024 20:55:10 GMT+0800 using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
